I"Ì<p>When writing <a href="/pyrrtm">pyrrtm</a>, I wrapped a large FORTRAN code using a cython interface. The original FORTRAN code was written as a standalone program, taking ASCII input files and producing ASCII output files, and so errors in the FORTRAN code were simply coded to print an error message and terminate the program. For example, using the following code to detect an error is common throughout the code base:</p>

<figure class="highlight"><pre><code class="language-fortran" data-lang="fortran"><span class="w">      </span><span class="k">IF</span><span class="w"> </span><span class="p">(</span><span class="o">&lt;</span><span class="n">some</span><span class="w"> </span><span class="n">condition</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="k">STOP</span><span class="w"> </span><span class="s2">"Error message here..."</span></code></pre></figure>

<p>Unfortunately, when wrapped using cython, such code kills the python process, and this is not really satisfactory.</p>

<p>In order to handle these errors gracefully, we need to do these things:</p>
<ol>
  <li>We must stop executing the FORTRAN code and return to python. We cannot just allow execution to proceed, as we could walk into a segfault doing this.</li>
  <li>We need to save the error message.</li>
  <li>We must be able to call the FORTRAN code again after the error.</li>
</ol>

<p>To accomplish these things, we have to replace the <code class="language-plaintext highlighter-rouge">STOP</code> command with some subroutine that can carry out various operations. (We canâ€™t just use <code class="language-plaintext highlighter-rouge">atexit</code> to set up a callback on <code class="language-plaintext highlighter-rouge">STOP</code> as the program must continue to terminate after such a call.) Therefore, the first challenge is to write a script that is able to replace</p>

<figure class="highlight"><pre><code class="language-fortran" data-lang="fortran"><span class="w">      </span><span class="k">IF</span><span class="w"> </span><span class="p">(</span><span class="o">&lt;</span><span class="n">some</span><span class="w"> </span><span class="n">condition</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="k">STOP</span><span class="w"> </span><span class="s2">"Error message here..."</span></code></pre></figure>

<p>with</p>

<figure class="highlight"><pre><code class="language-fortran" data-lang="fortran"><span class="w">      </span><span class="k">IF</span><span class="w"> </span><span class="p">(</span><span class="o">&lt;</span><span class="n">some</span><span class="w"> </span><span class="n">condition</span><span class="o">&gt;</span><span class="p">)</span><span class="w"> </span><span class="k">CALL</span><span class="w"> </span><span class="n">RRTMERR</span><span class="p">(</span><span class="s2">"Error message here..."</span><span class="p">)</span></code></pre></figure>

<p>where <code class="language-plaintext highlighter-rouge">RRTMERR</code> is some subroutine that will handle the error. Due to the intricacies of FORTRAN 77â€™s fixed column width and formatting, this is quite annoying to write (lots of corner cases) but can be made to work throughout the code base. I ended up writing a script that could handle about 95% of all occurrences of <code class="language-plaintext highlighter-rouge">STOP</code>, and then fixing the few exceptional cases by hand. Once this is complete, we just have to understand how to write the <code class="language-plaintext highlighter-rouge">RRTMERR</code> subroutine.</p>

<p>To address point 1 above, it is clear that the <code class="language-plaintext highlighter-rouge">RRTMERR</code> subroutine cannot return execution to the FORTRAN code. One way to achieve this is to use <code class="language-plaintext highlighter-rouge">setjmp</code> and <code class="language-plaintext highlighter-rouge">longjmp</code> in C, so I constructed a thin C wrapper that would just call the FORTRAN commands, but wrap them in a <code class="language-plaintext highlighter-rouge">setjmp</code> statement. It returns an error code depending on whether <code class="language-plaintext highlighter-rouge">longjmp</code> has been called:</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">jmp_buf</span> <span class="n">rrtmerr_jump</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">rrtmsafe_run</span><span class="p">(...)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span> <span class="n">setjmp</span><span class="p">(</span><span class="n">rrtmerr_jump</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
    <span class="c1">// run call our fortran subroutines to perform task</span>
    <span class="p">...</span>
    <span class="c1">// return 0 to indicate success.</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// if we get to here, there was an error.</span>
  <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>The C wrapper also provides the <code class="language-plaintext highlighter-rouge">RRTMERR</code> subroutine, which in C is called the <code class="language-plaintext highlighter-rouge">rrtmerr_</code> function (for the GNU compilers). This function simply saves the message as a global variable (which will be accessed by cython), and then calls <code class="language-plaintext highlighter-rouge">longjmp</code>. The <code class="language-plaintext highlighter-rouge">rrtmerr_</code> function is called explicitly with the length of the string, as FORTRAN does not null-terminate the string for us.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="kt">void</span> <span class="nf">rrtmerr_</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span> <span class="n">message</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span> <span class="n">length</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// this function will be called from fortran</span>
  <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="n">length</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
  <span class="c1">// copy the message string into global variable rrtmerr_message</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">rrtmerr_message</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">message</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
  <span class="p">}</span>
  <span class="n">rrtmerr_message</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sc">'\0'</span><span class="p">;</span>
  <span class="c1">// return control to run_rrtm.</span>
  <span class="n">longjmp</span><span class="p">(</span><span class="n">rrtmerr_jump</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span></code></pre></figure>

<p>This solution now gracefully allows errors to be handled in FORTRAN and control returned to cython and python. The cython code simply interprets the return code of <code class="language-plaintext highlighter-rouge">rrtmsafe_run</code> and raises an exception if necessary.</p>
:ET