I"G<p>A long while ago, I wrote a script for
<a href="http://www.matplotlib.org">matplotlib</a> that later (after lots of work by
<a href="http://www.tonysyu.com/">Tony Yu</a> and others) became the matplotlib
<a href="http://matplotlib.org/api/pyplot_api.html?highlight=streamplot#matplotlib.pyplot.streamplot"><code class="language-plaintext highlighter-rouge">streamplot</code></a>
function. This function generates plots that are constructed out of
streamlines of a flow, in such a way as to fill the domain uniformly
with such streamlines. I wrote the script to plot winds in the
tropical upper troposphere/lower stratosphere where there is a lot of
divergence and convergence (principally caused by convection over the
western Pacific and subsidence over the eastern Pacific.)</p>

<div class="thumbnail">
<img alt="Example of streamplot" src="/assets/wind_example.jpg" />
</div>

<p>The <code class="language-plaintext highlighter-rouge">streamplot</code> algorithm uses an adaptive 1st/2nd order
<a href="http://en.wikipedia.org/wiki/Runge%E2%80%93Kutta_methods">Runge-Kutta</a>
scheme and linear interpolation of the velocity field to integrate the
streamlines. This was implemented in pure python, which I originally
chose to do because the portion of the algorithm responsible for
ensuring an even domain-filling distribution of streamlines imposes a
very strange termination condition on the integral that does not fit
well with the integrators in <code class="language-plaintext highlighter-rouge">scipy</code>. In addition, matplotlib does not
depend on <code class="language-plaintext highlighter-rouge">scipy</code>.</p>

<p>I initially expected a pure python algorithm to be incredibly slow, so
I used a very simple interpolation scheme. Any interpolation scheme
interpolating some data <code class="language-plaintext highlighter-rouge">D[i]</code> defined at points <code class="language-plaintext highlighter-rouge">x[i]</code> on to the
target point <code class="language-plaintext highlighter-rouge">x0</code> is composed of two steps; first, the algorithm must
identify the nearest grid points to the target point. Second, the
interpolator must apply the appropriate interpolator to those
neighbouring points.</p>

<p>The second step is usually trivial to implement, but the first step is
non-trivial in general. The first step becomes a lot simpler when we
restrict ourselves to a regular grid with spacing <code class="language-plaintext highlighter-rouge">dx</code> as we can then
find the index <code class="language-plaintext highlighter-rouge">i</code> of the point just above <code class="language-plaintext highlighter-rouge">x0</code> by rescaling and
casting to an integer</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">i</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="n">x0</span> <span class="o">-</span> <span class="n">x</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">/</span> <span class="n">dx</span><span class="p">)</span></code></pre></figure>

<p>I thought this was probably the fastest way of implementing an
interpolator and so used this technique to implement the interpolator
in <code class="language-plaintext highlighter-rouge">streamplot</code>. However, it added some complexity to the algorithm
and, most importantly, <em>imposed a restriction that only regular grids
(i.e. grids with evenly spaced axes) could be used</em>. For my original
purpose, this was not a problem but it is clearly a rather serious
limitation in general.</p>

<p>Recently I have been hitting this limitation and decided over the last
couple of evenings to try to free <code class="language-plaintext highlighter-rouge">streamplot</code> of this limitation. To
generalise the first interpolation step to work with any <code class="language-plaintext highlighter-rouge">x[i]</code>, a
search is needed to find the smallest <code class="language-plaintext highlighter-rouge">i</code> such that <code class="language-plaintext highlighter-rouge">x[i] &gt; x0</code>. Any
pure python search algorithm would be too slow. Using <code class="language-plaintext highlighter-rouge">argmax</code> to do a
linear search is an option:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">i</span> <span class="o">=</span> <span class="n">numpy</span><span class="p">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">x0</span><span class="p">)</span></code></pre></figure>

<p>However, this does not scale well with the length of each dimension
and is too slow in this context.</p>

<p>Looking through the standard library, I came across the <code class="language-plaintext highlighter-rouge">bisect</code>
module which implements the
<a href="http://en.wikipedia.org/wiki/Bisection_method">interval bisection method</a>
for searching ordered lists and arrays – exactly what I needed
to do.  Implementing this search is really simple; it’s just</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">i</span> <span class="o">=</span> <span class="n">bisect</span><span class="p">.</span><span class="n">bisect</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">x0</span><span class="p">)</span></code></pre></figure>

<p>This method is really fast – way faster than I expected. After
re-implementing the streamplot integrator and interpolator to use this
type of interpolation, typical plotting times were barely increased.</p>

<p>Here is an example of the new script in action with a very
non-uniform vertical grid spacing:</p>

<div class="thumbnail">
<img alt="Example with uneven grid" src="/assets/walker.jpg" />
</div>

<p>(This plot shows the boreal winter average zonal and vertical winds in
the inner tropics.)</p>

<p>The new script is available
<a href="https://github.com/tomflannaghan/matplotlib/blob/streamplot-real-space-integrate/lib/matplotlib/streamplot.py">here</a>. Feel
free to try it out if you need to do streamplots with uneven
grids. Please note that this is a work-in-progress and so use with
caution :-)</p>
:ET